本文配合[面试官：双亲委派模型你了解吗？](https://juejin.cn/post/7020935051860770853)食用效果更佳。

- Bootstrap ClassLoader，Extension ClassCloader，Application ClassCloader继承于ClassLoader.java类吗？

  Bootstrap ClassLoader不是，而Extension ClassCloader，Application ClassCloader是。

  - Bootstrap ClassLoader加载器是用c++进行编写，是虚拟机的一部分，c++类继承于java类本是无稽之谈。

  - ExtensionClassCloader其class文件在sun.misc.Launcher$ExtClassLoader.class中，可以找到这个文件并在[Decompilers online](http://www.javadecompilers.com/)对其进行反编译获取其源码文件。

    ```java
    static class ExtClassLoader extends URLClassLoader
    {
    ...
    }
    ```

    URLClassLoader继承SecureClassLoader。

    ```java
    public class URLClassLoader extends SecureClassLoader implements Closeable {
    ...
    }
    ```

    SecureClassLoader又继承于ClassLoader。

    ```java
    public class SecureClassLoader extends ClassLoader {
    }
    ```

  - ApplicationClassLoader其class文件是sun.misc.Launcher$AppClassLoader，我们可以对其重复同样的操作。

    ```java
    static class AppClassLoader extends URLClassLoader
    {
    ...
    }
    ```

    可以发现，其同样继承于URLClassLoader。

- 可以加载一个全限定名和系统String类一样的自定义String类吗？

  不可以。

  加载一个自定义类首先要求我们必须自定义一个继承于ClassCloader类的加载器。

  即使我们通过复写该自定义加载器的loadClass()来破坏双亲加载模型，在加载过程中一定会调用到ClassLoader::preDefineClass()方法。

  ```java
      private ProtectionDomain preDefineClass(String name,
                                              ProtectionDomain pd)
      {
          if (!checkName(name))
              throw new NoClassDefFoundError("IllegalName: " + name);
  
          // Note:  Checking logic in java.lang.invoke.MemberName.checkForTypeAlias
          // relies on the fact that spoofing is impossible if a class has a name
          // of the form "java.*"
          if ((name != null) && name.startsWith("java.")
                  && this != getBuiltinPlatformClassLoader()) {
              throw new SecurityException
                  ("Prohibited package name: " +
                   name.substring(0, name.lastIndexOf('.')));
          }
  				...
          return pd;
      }
  ```

  如上所示，该方法一当发现待加载类的全限定名以java.开头，就会抛异常，而系统类String的全限定名就是java.lang.String.class。

- 那么系统是怎么加载String类的？

  String.class被放在了<JAVA_HOME>/jre/lib/rt.jar文件中，由Bootstrap加载器进行加载，而Bootstrap加载器不继承于ClassLoader类。

### 参考资料

1. 《深入理解Java虚拟机》，周志明

2. [A custom String class creation](https://stackoverflow.com/questions/14332590/a-custom-string-class-creation)

3. [Why do we use rt.jar in a java project?](https://stackoverflow.com/questions/3091040/why-do-we-use-rt-jar-in-a-java-project)

   
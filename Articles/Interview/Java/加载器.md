- 可以加载一个全限定名和系统String类一样的自定义String类吗？

  不可以。

  加载一个自定义类首先要求我们必须自定义一个继承于ClassCloader类的加载器。

  即使我们通过复写该自定义加载器的loadClass()来破坏双亲加载模型，在加载过程中一定会调用到ClassLoader::preDefineClass()方法。

  ```java
      private ProtectionDomain preDefineClass(String name,
                                              ProtectionDomain pd)
      {
          if (!checkName(name))
              throw new NoClassDefFoundError("IllegalName: " + name);
  
          // Note:  Checking logic in java.lang.invoke.MemberName.checkForTypeAlias
          // relies on the fact that spoofing is impossible if a class has a name
          // of the form "java.*"
          if ((name != null) && name.startsWith("java.")
                  && this != getBuiltinPlatformClassLoader()) {
              throw new SecurityException
                  ("Prohibited package name: " +
                   name.substring(0, name.lastIndexOf('.')));
          }
  				...
          return pd;
      }
  ```

  如上所示，该方法一当发现待加载类的全限定名以java.开头，就会抛异常，而系统类String的全限定名就是java.lang.String.class。

- 那么系统是怎么加载String类的？

  String.class被放在了<JAVA_HOME>/jre/lib/rt.jar文件中，由Bootstrap加载器进行加载，该加载器用c++进行编写，是虚拟机的一部分。

### 参考资料

1. [A custom String class creation](https://stackoverflow.com/questions/14332590/a-custom-string-class-creation)

2. [Why do we use rt.jar in a java project?](https://stackoverflow.com/questions/3091040/why-do-we-use-rt-jar-in-a-java-project)

   
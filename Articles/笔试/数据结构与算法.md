### 查找

笔试中该部分往往会考察分别用线性探测法和拉链法处理散列表中的冲突的平均查找成功长度和平均查找失败长度。

- 线性探测法

  **例题**：关键字序列为{19,14,23,01,68,20,84,27,55,11,10,79}，按散列函数H(key)=key%13和线性探测处理沖突构造散列表，其中散列表长度为16。

  **解**：以第一个数字19为例。

  <p align="center">H(19)=19%13=6</p>
  
  
  此时，没有造成冲突，所以比较次数为1，有了这些数据，就可以初步构造表格。
  
  <p align="center"><img src="https://raw.githubusercontent.com/DoubleYellowIce/AndroidTechArticlesStorage/master/imgs/image-20220814134826320.png"></img></p>
  
  如果遇到了冲突，以关键字14和27为例，在处理关键字27之前的表格是
  
  <p align="center"><img src="https://raw.githubusercontent.com/DoubleYellowIce/AndroidTechArticlesStorage/master/imgs/image-20220814141538627.png"></img></p>
  
  将关键字27代入哈希函数进行计算。
  
  <p align="center">H(27)=27%13=1</p>
  
  这时候发现会散列表中下标为1的位置已经被关键字14占了，这是因为
  
  <p align="center">H(14)=14%13=1</p>
  

  解决冲突的方法就是顺序遍历散列表，将27挪到下一个为空的位置，下标为1，2，3的位置都不为空，因此只能将27放在下标为4的位置上，造成了冲突，由于比较了下标为1，2，3，4的位置，比较次数为4。

  <p align="center"><img src="https://raw.githubusercontent.com/DoubleYellowIce/AndroidTechArticlesStorage/master/imgs/image-20220814142204488.png"></img></p>
  
  对数列中的其它数字如法炮制，最终就可以得到下列表格。
  
  <p align="center"><img src="https://raw.githubusercontent.com/DoubleYellowIce/AndroidTechArticlesStorage/master/imgs/image-20220814135041743.png"></img></p>

  - 平均查找成功长度就为每个关键字的比较次数之和除以关键字个数。

    

  $$
  ASLSuccess=\frac{1\times6+2+3\times3+4+9}{12}=2.5
  $$

  

  - 平均查找失败长度就为查找次数之和除以散列后的地址个数。

    - 查找次数
  
      查找次数等于下标到下一个空关键字的距离。

      以两个特殊点，散列表中下标0和下标1的位置为例。

      - 下标0的位置。

        假设查找13，根据散列函数可得

        <p align="center">H(0)=13%13=0</p>
        
        
        从下标0的位置，开始查找。
        
        1. 下标0的位置为空，查找失败。
        
        此时查找长度为1。
        
      - 下标1的位置
      
        假设查找数字43，根据散列函数可得
      
        <p align="center">H(43)=43%13=1</p>
        
        
        从下标1位置，也就是关键字14所在的位置，开始查找。
        
        1. 43不等于14，下一个。
        2. 43不等于01，下一个。
        3. ..
        4. 43不等于10，下一个。
        5. 下标为13的位置关键字为空，查找失败
        
        此时查找长度为13。
      
    - 散列后的地址个数
    
      该数字固定为散列函数%符号后的数字，在这里是13。

    因此平均查找失败长度为

    
    $$
    ASLUnsuccess=\frac{1+13+12+11..+2}{13}=7
    $$
    
  - 为什么第一次查找目标值失败之后还要继续往后找？
  
    这是因为在构造散列表的时候，处理冲突的办法是将造成冲突的关键字移动至下一个为空的位置，所以在第一次查找失败后，仍然有目标值在后面的可能性，所以要继续查找。
  
  - 那为什么遇到空位置就可以判定为查找失败？
  
    这个问题可以用反证法去解释。
  
    **假设**目标值存在，且位于空位置之后。
  
    而根据构造散列表时的冲突处理策略，目标值如果存在，那么应该就会移动到此刻遍历位置上，这个结论与事实不符，假设不成立，因此目标值不存在。

- 拉链法

  **例题**: 关键字序列为{19,14,23,01,68,20,84,27,55,11,10,79},散列函数为H(key)=key%13，用拉链法解决冲突。

  构图部分比较简单，这里就不再赘述，直接上图。

  <p align="center"><img src="https://raw.githubusercontent.com/DoubleYellowIce/AndroidTechArticlesStorage/master/imgs/image-20220816152717199.png"></img></p>

  - 平均查找成功长度

    计算方式为每个关键字查找次数之和除以关键字个数。

    以关键字27为例，其位置在于下标为1的的链表上，由于它是链表的第三个关键字，因此其查找次数为3，可以发现关键字的查找次数与其在第几个链表无关，而是与其在链表中的位置有关，因此可得

    
    $$
    ASLSuccess=\frac{1\times 6+2\times 4+3+4}{12}=1.75
    $$
    

  - 平均查找失败长度

    计算方式为每个下标的查找失败次数之和下除以散列后的地址个数。

    - 每个下标的查找失败次数之和

      以下标1为例，其链表长度为4，只有遍历完整个链表才能确定查找失败，故查找失败长度为4+1=5，这里+1是因为查询空结点也算一次查询。

    - 散列后的地址个数

      该数字固定为散列函数%符号后的数字，在这里是13。

    $$
    ASLUnsuccess=\frac{1+5+1+3..+3+2+1}{13}=\frac{25}{13}
    $$

### 排序

- 插入排序

  插入排序比较简单，就是从无序序列中挑选一个元素插入到有序序列中，要求新元素插入后序列仍需保持有序状态。

  - 时间复杂度。

    新元素是从后向前比较有序序列的元素来确定其最终的位置。

    - 最优时间复杂度

      待排序序列本身是有序的，由于是从后向前比较，故最优时间复杂度为

      
      $$
      O(n)
      $$

    - 最坏时间复杂度

      待排序序列是逆序的，那么

      - 第一个元素插入时，有序序列为空，需要比较0次。
      - 第二个元素插入时，有序序列有1个比它大的元素，需要比较1次。
      - ..
      - 第n个元素插入时，有序序列有n-1个比它大的元素，需要比较n-1次。

      由等差数列求和公式可得

      
      $$
      O(n)=\frac{n\times{(n-1+0)}}{2}\approx O(n^{2})
      $$

  - 稳定性。

    由于是从后往前比较有序序列，所以插入排序是稳定的。

- 希尔排序

  希尔排序的算法如下所示。

  1. 把序列划分为多个[i,i+d,i+2d,..,i+kd]子序列，然后对子序列进行排序，
  2. d减2，重复步骤1的操作，直到d为1。

  步骤1中d为增量，一开始一般会设置为序列长度的一半，i代表起始位置。

  **例题**：

  <p align="center"><img src="https://raw.githubusercontent.com/DoubleYellowIce/AndroidTechArticlesStorage/master/imgs/image-20220819164709232.png"></img></p>

  - 时间复杂度

    上面提到过，希尔排序的增量d不是固定值，而增量d的值会影响到划分子序列来进行排序的次数，因此希尔排序的时间复杂度是比较难分析的，是不确定的。

  - 稳定性

    希尔排序是不稳定的，因为相同大小的数字可能会被分到不同的子序列中，因此可能会出现相同大小的数字相对顺序改变的情况。

  

  

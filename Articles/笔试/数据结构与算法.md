### 查找

笔试中该部分往往会考察分别用线性探测法和拉链法处理散列表中的冲突的平均成功查找长度和平均失败查找长度。

- 线性探测法

  **例题**：关键字序列为{19,14,23,01,68,20,84,27,55,11,10,79}，按散列函数H(key)=key%13和线性探测处理沖突构造散列表，其中散列表长度为16。

  **解**：以第一个数字19为例。

  
  $$
  H(19)=19\%13=6
  $$
  

  此时，没有造成冲突，所以比较次数为1，有了这些数据，就可以初步构造表格。

  <p align="center"><img src="https://raw.githubusercontent.com/DoubleYellowIce/AndroidTechArticlesStorage/master/imgs/image-20220814134826320.png"></img></p>

  如果遇到了冲突，以关键字14和27为例，在处理关键字27之前的表格是

  <p align="center"><img src="https://raw.githubusercontent.com/DoubleYellowIce/AndroidTechArticlesStorage/master/imgs/image-20220814141538627.png"></img></p>

  
  $$
  H(27)=27\%13=1
  $$
  

  这时候发现会散列表中下标为1的位置已经有被关键字14占了，这是因为

  
  $$
  H(14)=14\%13=1
  $$
  

  那么只好顺序遍历散列表，将27挪到下一个为空的位置，下标为1，2，3的位置都不为空，因此只能将27放在下标为4的位置上，造成了冲突，由于比较了下标为1，2，3，4的位置，比较次数为4。

  <p align="center"><img src="https://raw.githubusercontent.com/DoubleYellowIce/AndroidTechArticlesStorage/master/imgs/image-20220814142204488.png"></img></p>

  对数列中的其它数字如法炮制，最终就可以得到下列表格。

  <p align="center"><img src="https://raw.githubusercontent.com/DoubleYellowIce/AndroidTechArticlesStorage/master/imgs/image-20220814135041743.png"></img></p>

  - 平均成功查找长度就为比较次数之和除以元素个数。

    

  $$
  ASLSuccess=\frac{1\times6+2+3\times3+4+9}{12}=2.5
  $$

  

  - 平均查找失败长度就为查找次数除以散列后的地址个数。

    - 查找长度

      查找次数的计算方式是每个关键字到下一个空关键字的距离长度之和。

      以两个特殊点，散列表中下标0和下标1的位置。

      - 下标0的位置。

        假设查找13，根据散列函数可得

        
        $$
        H(0)=13\%13=0
        $$
        

        从下标0的位置，开始查找。

        1. 下标0的位置为空，查找失败。

        此时查找长度为1。

      - 下标1的位置

        假设查找数字43，根据散列函数可得

        
        $$
        H(43)=43\%13=1
        $$
        

        从下标1位置，也就是关键字14所在的位置，开始查找。

        1. 43不等于14，下一个。
        2. 43不等于01，下一个。
        3. ..
        4. 43不等于10，下一个。
        5. 下标为13的位置关键字为空，查找失败

        此时查找长度为13。

    - 散列后的地址个数

      该数字固定为散列函数%符号后的数字，在这里是13。

    因此平均查找失败长度为

    
    $$
    ASLUnsuccess=\frac{1+13+12+11..+2}{13}=7
    $$
    

  - 为什么第一次查找目标值失败之后还要继续往后找？

    这是因为在构造散列表的时候，处理冲突的办法是将造成冲突的关键字移动至下一个为空的位置，所以在第一次查找失败后，仍然有目标值在后面的可能性，所以要继续查找。

  - 那为什么遇到空位置就可以判定为查找失败？

    这个问题可以用反证法去解释。

    **假设**目标值存在，且位于空位置之后。

    而根据构造散列表时的冲突处理策略，目标值如果存在，那么应该就会移动到这一个位置上，也就是说，此刻遍历位置应该不为空，这个结论与事实不符，假设不成立，因此目标值不存在。

​					
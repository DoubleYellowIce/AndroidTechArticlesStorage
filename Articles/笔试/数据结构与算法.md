### 查找

笔试中该部分往往会考察分别用线性探测法和拉链法处理散列表中的冲突的平均查找成功长度和平均查找失败长度。

#### 线性探测法

**例题**：关键字序列为{19,14,23,01,68,20,84,27,55,11,10,79}，按散列函数H(key)=key%13和线性探测处理沖突构造散列表，其中散列表长度为16。

**解**：以第一个数字19为例。

<p align="center">H(19)=19%13=6</p>


此时，没有造成冲突，所以比较次数为1，有了这些数据，就可以初步构造表格。

<p align="center"><img src="https://raw.githubusercontent.com/DoubleYellowIce/AndroidTechArticlesStorage/master/imgs/image-20220814134826320.png"></img></p>

如果遇到了冲突，以关键字14和27为例，在处理关键字27之前的表格是

<p align="center"><img src="https://raw.githubusercontent.com/DoubleYellowIce/AndroidTechArticlesStorage/master/imgs/image-20220814141538627.png"></img></p>

将关键字27代入哈希函数进行计算。

<p align="center">H(27)=27%13=1</p>

这时候发现会散列表中下标为1的位置已经被关键字14占了，这是因为

<p align="center">H(14)=14%13=1</p>


解决冲突的方法就是顺序遍历散列表，将27挪到下一个为空的位置，下标为1，2，3的位置都不为空，因此只能将27放在下标为4的位置上，造成了冲突，由于比较了下标为1，2，3，4的位置，比较次数为4。

<p align="center"><img src="https://raw.githubusercontent.com/DoubleYellowIce/AndroidTechArticlesStorage/master/imgs/image-20220814142204488.png"></img></p>

对数列中的其它数字如法炮制，最终就可以得到下列表格。

<p align="center"><img src="https://raw.githubusercontent.com/DoubleYellowIce/AndroidTechArticlesStorage/master/imgs/image-20220814135041743.png"></img></p>

- 平均查找成功长度就为每个关键字的比较次数之和除以关键字个数。

  

$$
ASLSuccess=\frac{1\times6+2+3\times3+4+9}{12}=2.5
$$



- 平均查找失败长度就为查找次数之和除以散列后的地址个数。

  - 查找次数

    查找次数等于下标到下一个空关键字的距离。

    以两个特殊点，散列表中下标0和下标1的位置为例。

    - 下标0的位置。

      假设查找13，根据散列函数可得

      <p align="center">H(0)=13%13=0</p>
      
      
      从下标0的位置，开始查找。
      
      1. 下标0的位置为空，查找失败。
      
      此时查找长度为1。
      
    - 下标1的位置
    
      假设查找数字43，根据散列函数可得
    
      <p align="center">H(43)=43%13=1</p>
      
      
      从下标1位置，也就是关键字14所在的位置，开始查找。
      
      1. 43不等于14，下一个。
      2. 43不等于01，下一个。
      3. ..
      4. 43不等于10，下一个。
      5. 下标为13的位置关键字为空，查找失败
      
      此时查找长度为13。
    
  - 散列后的地址个数
  
    该数字固定为散列函数%符号后的数字，在这里是13。

  因此平均查找失败长度为

  
  $$
  ASLUnsuccess=\frac{1+13+12+11..+2}{13}=7
  $$
  
- 为什么第一次查找目标值失败之后还要继续往后找？

  这是因为在构造散列表的时候，处理冲突的办法是将造成冲突的关键字移动至下一个为空的位置，所以在第一次查找失败后，仍然有目标值在后面的可能性，所以要继续查找。

- 那为什么遇到空位置就可以判定为查找失败？

  这个问题可以用反证法去解释。

  **假设**目标值存在，且位于空位置之后。

  而根据构造散列表时的冲突处理策略，目标值如果存在，那么应该就会移动到此刻遍历位置上，这个结论与事实不符，假设不成立，因此目标值不存在。

#### 拉链法

**例题**: 关键字序列为{19,14,23,01,68,20,84,27,55,11,10,79},散列函数为H(key)=key%13，用拉链法解决冲突。

构图部分比较简单，这里就不再赘述，直接上图。

<p align="center"><img src="https://raw.githubusercontent.com/DoubleYellowIce/AndroidTechArticlesStorage/master/imgs/image-20220816152717199.png"></img></p>

- 平均查找成功长度

  计算方式为每个关键字查找次数之和除以关键字个数。

  以关键字27为例，其位置在于下标为1的的链表上，由于它是链表的第三个关键字，因此其查找次数为3，可以发现关键字的查找次数与其在第几个链表无关，而是与其在链表中的位置有关，因此可得

  
  $$
  ASLSuccess=\frac{1\times 6+2\times 4+3+4}{12}=1.75
  $$
  
- 平均查找失败长度

  计算方式为每个下标的查找失败次数之和下除以散列后的地址个数。

  - 每个下标的查找失败次数之和

    以下标1为例，其链表长度为4，只有遍历完整个链表才能确定查找失败，故查找失败长度为4+1=5，这里+1是因为查询空结点也算一次查询。

  - 散列后的地址个数

    该数字固定为散列函数%符号后的数字，在这里是13。

  $$
  ASLUnsuccess=\frac{1+5+1+3..+3+2+1}{13}=\frac{25}{13}
  $$

### 排序

可在[Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html)观看各个排序算法相对应的动画演示，更有助于理解。

在这里对每个排序都会提到的稳定性做一个简单的讲解。

稳定性的评判标准是相同数字在排序前后的相对位置是否会发生改变，若没有发生改变，则该排序算法是稳定的，若发生了改变，则反之。

#### 插入排序(Insertion Sort)

插入排序比较简单，就是从无序序列中挑选一个元素插入到有序序列中，要求新元素插入后序列仍需保持有序状态。

- 时间复杂度。

  新元素是从后向前比较有序序列的元素来确定其最终的位置。

  - 最优时间复杂度

    待排序序列本身是有序的，由于是从后向前比较，故最优时间复杂度为

    
    $$
    O(n)
    $$

  - 最坏时间复杂度

    待排序序列是逆序的，那么

    - 第一个元素插入时，有序序列为空，需要比较0次。
    - 第二个元素插入时，有序序列有1个比它大的元素，需要比较1次。
    - ..
    - 第n个元素插入时，有序序列有n-1个比它大的元素，需要比较n-1次。

    由等差数列求和公式可得

    
    $$
    O(n)=\frac{n\times{(n-1+0)}}{2}\approx O(n^{2})
    $$

- 稳定性。

  由于是从后往前比较有序序列，所以插入排序是稳定的。

#### 希尔排序(Shell Sort)

希尔排序的算法如下所示。

1. 把序列划分为多个[i,i+d,i+2d,..,i+kd]子序列，然后对子序列进行排序，
2. d减2，重复步骤1的操作，直到d为1。

步骤1中d为增量，一开始一般会设置为序列长度的一半，i代表起始位置。

**例题**：

<p align="center"><img src="https://raw.githubusercontent.com/DoubleYellowIce/AndroidTechArticlesStorage/master/imgs/image-20220819164709232.png"></img></p>

- 时间复杂度

  上面提到过，希尔排序的增量d不是固定值，而增量d的值会影响到划分子序列来进行排序的次数，因此希尔排序的时间复杂度是比较难分析的，是不确定的。

- 稳定性

  希尔排序是不稳定的，因为相同大小的数字可能会被分到不同的子序列中，因此可能会出现相同大小的数字相对顺序改变的情况。

#### 选择排序(Selection Sort)

选择排序是指从未排序的序列中取出最小的元素插入到有序序列中。

- 时间复杂度

  设序列长度为n。

  - 第一次。序列[0,n-1]都是无序的，因此需要遍历n个元素。
  - 第二次。序列[1,n-1]都是无序的，因此需要遍历n-1个元素。
  - ..
  - 第n-1次。序列[n-2,n-1]是无序的，因此需要遍历2个元素。

  同样由等差数列求和公式可得时间复杂度为O(n)。

- 与插入排序的区别。

  选择排序每次选择的元素都是无序序列中最小的一个，而插入排序每次选择的元素都是无序序列中第一个元素。

- 稳定性

  不稳定。

  **例子**：用选择排序对序列[3,3‘,1]进行排序。

  第一次排序过后，序列会变成[1,3',3]。

#### 基数排序(Radix Sort)

基数排序算法比较好理解，过程如下，

- 对序列中所有数字按个位进行排序。
- 对序列中所有数字按十位进行排序。

- 对序列中所有数字按百位进行排序。
- ...
- 对序列中所有数字按最高位进行排序。

具体可看[动画演示](https://www.cs.usfca.edu/~galles/visualization/RadixSort.html)。

- 时间复杂度

  设序列中的元素个数为n，所有元素中的最高位为k，那么总共需要排序k次，每次需要遍历n个元素，因此时间复杂度为
  $$
  O(k\times n )
  $$

- 稳定性

  稳定，因为相同数字的所有位大小一样，而遍历元素时会从左至右进行遍历，所以相对位置不会发生改变。

#### 冒泡排序(Bubble Sort)

冒泡排序基于两两比较。

- 遍历顺序。

  - 从前往后。

    一开始的遍历范围为[0,len-1]，len为序列的长度。

    每次遍历都会把此刻遍历范围的最大值放到遍历范围的最后一个位置，之后就遍历范围就往左缩小一个单位长度。

    例如，第一次的遍历范围为[0,len-1]，那么此时最大值就会被放到下标为len-1的位置，之后第二次的遍历范围就会变成[0,len-2]，依次类推。

  - 从后往前。

    同样地，一开始的遍历范围为[0,len-1]。

    每次遍历都会把此刻遍历范围的最小值放到遍历范围的第一个位置，之后就遍历范围就往右缩小一个单位长度。

    例如，第一次的遍历范围为[0,len-1]，那么此时最小值就会被放到下标为0的位置，之后第二次的遍历范围就会变成[1,len-1]，依次类推。

- 时间复杂度

  从上文就可以发现冒泡排序的时间复杂度是固定的，因为不管序列原本状态是有序还是无序，其都要遍历同样的次数，n，n-1，..1。

  同样由等差数列的求和公式可得
  $$
  O(\frac{n\times(1+n)}{2})\approx O(n^{2})
  $$

- 思想应用

  尽管冒泡排序的时间复杂度不低，不是重要的算法，但其两两比较的思想是有一定的借鉴意义的。

  以力扣上[1460. 通过翻转子数组使两个数组相等](https://leetcode.cn/problems/make-two-arrays-equal-by-reversing-sub-arrays/)为例，题目如下所示。

  <p align="center"><img src="https://raw.githubusercontent.com/DoubleYellowIce/PicBed/main/imgs/image-20220826153239021.png?token=APSPKF3575HU2MOWKIWJSQLDBB3VI"></img></p>

  大概瞄一眼，可能会觉得这道题不好做，其实不是的，仔细看红框所圈住的内容，就会发现翻转是可以进行两两比较的，而冒泡排序正是基于两两比较的，因此arr经过一定的翻转次数可以变成任意我们想要的序列，只需要确定target和arr数组的元素一致就好。

  做法就是分别将target和arr排好序后，判断两者的元素是否相同，代码如下所示。

  ```java
  class Solution {
      public boolean canBeEqual(int[] target, int[] arr) {
          Arrays.sort(target);
          Arrays.sort(arr);
          int len=target.length;
          for (int i=0;i<len;i++){
              if (arr[i]!=target[i]){
                  return false;
              }
          }
          return true;
      }
  }
  ```

  

